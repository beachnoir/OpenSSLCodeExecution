#!/usr/bin/env python3

from Crypto.Cipher import AES
from Crypto.Util.Padding import pad

import subprocess
import argparse
import os

def main(input_file, output_file):
	
	enc_file = input_file[:-3] + '.enc'
	engine = open(input_file, 'rb').read()
	key = b'\x00' * 16
	engine = pad(engine, 16)
	head = engine[:16]
	tail = engine[16:] + b'\x00' * 16
	ct1 = AES.new(key, AES.MODE_ECB).encrypt(tail[:16])

	for padding in range(1024):
		serial_test = int.from_bytes(b'\x41' * len(tail) + b'\x41' * padding, 'big')
		cmd = generate_cert_cmd(serial_test, enc_file)
		subprocess.run(cmd)
		cert = open(enc_file, 'rb').read()
		ct0 = cert[:16]
		IV = xor(head, AES.new(key, AES.MODE_ECB).decrypt(ct0))
		ct = AES.new(key, AES.MODE_CBC, iv = ct0).encrypt(tail)
		answer = ct[1:] + b'\x41' * (padding+1)
		serial_test = int.from_bytes(answer, 'big')
		cmd = generate_cert_cmd(serial_test, enc_file)
		subprocess.run(cmd)
		cert = open(enc_file, 'rb').read()
		pt = AES.new(key, AES.MODE_CBC, iv = IV).decrypt(pad(cert, 16))
		if pt[:128] == engine[:128]:
			size = os.get_terminal_size()
			print(f'Found matching IV after {padding} attempts!')
			print(f'*' * size.columns)
			print(f'To execute {input_file}, run the 3 openssl commands specified in {output_file} in order')
			with open(output_file, 'w') as file:
				file.write(f"openssl req -x509 -sha1 -nodes -days 1 -newkey rsa:512 -subj / -keyout /dev/null -out {enc_file} -outform der -set_serial {serial_test}\n")
				file.write(f"openssl enc -d -aes-128-cbc -K {key.hex()} -iv {IV.hex()} -in {enc_file} -out {input_file}\n")
				file.write(f"openssl req -engine $(pwd)/{input_file}\n")
			return

	print("Hmmm, something went wrong ...")
	return

def generate_cert_cmd(serial_test, input_name):
	cmd = ['openssl', 'req', '-x509', '-sha1', '-nodes', '-days', '1', '-newkey', 'rsa:512', '-subj', '/', '-keyout', '/dev/null', '-out', input_name, '-outform', 'der', '-set_serial', str(serial_test),]
	return cmd

def xor(a, b):
	return bytearray([a[x] ^ b[x] for x in range(min(len(a), len(b)))])

if __name__ == '__main__':
	parser = argparse.ArgumentParser(description = 'Given a shared object (.so) input file, finds the OpenSSL commands needed to execute it and writes them to an output file.')
	parser.add_argument('input', help = 'The .so input file name')
	parser.add_argument('output', help = 'The output file name')
	args = parser.parse_args()
	
	main(args.input, args.output)
